"use strict";(self.webpackChunkll_ms_metrics_catalog=self.webpackChunkll_ms_metrics_catalog||[]).push([[9146],{3915:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"metrics/accuracy-overlap/codescore","title":"CodeScore","description":"Overview","source":"@site/docs/metrics/accuracy-overlap/codescore.md","sourceDirName":"metrics/accuracy-overlap","slug":"/metrics/accuracy-overlap/codescore","permalink":"/LLMs-metrics-catalog/metrics/accuracy-overlap/codescore","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"codescore","title":"CodeScore","sidebar_label":"CodeScore"},"sidebar":"docsSidebar","previous":{"title":"chrF","permalink":"/LLMs-metrics-catalog/metrics/accuracy-overlap/chrf"},"next":{"title":"MoverScore","permalink":"/LLMs-metrics-catalog/metrics/accuracy-overlap/moverscore"}}');var s=n(4848),c=n(8453);const t={id:"codescore",title:"CodeScore",sidebar_label:"CodeScore"},a=void 0,l={},o=[{value:"Overview",id:"overview",level:2},{value:"Formula and Structure",id:"formula-and-structure",level:2},{value:"Variants",id:"variants",level:2},{value:"Application in Software Engineering",id:"application-in-software-engineering",level:2},{value:"Interpretation",id:"interpretation",level:2},{value:"References",id:"references",level:2},{value:"Additional References in Dataset",id:"additional-references-in-dataset",level:3}];function d(e){const i={a:"a",annotation:"annotation",br:"br",em:"em",h2:"h2",h3:"h3",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",msup:"msup",ol:"ol",p:"p",semantics:"semantics",span:"span",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"CodeScore is an execution-informed evaluation metric designed to measure the functional correctness of generated code without requiring direct code execution. It was introduced in the paper CodeScore: Evaluating Code Generation by Learning Code Execution (Dong et al., 2023) as a learned model-based proxy for traditional execution-based metrics. Unlike BLEU or CodeBLEU, which rely on textual overlap, CodeScore uses a trained model to infer how well generated code would perform on hidden test cases by learning representations of execution behavior.\r\nThe metric outputs a continuous score between 0 and 1 that reflects both executability and behavioral similarity between generated and reference code. It has been widely adopted in software engineering evaluation benchmarks, offering a balance between reliability and computational efficiency."}),"\n",(0,s.jsx)(i.h2,{id:"formula-and-structure",children:"Formula and Structure"}),"\n",(0,s.jsx)(i.p,{children:"The CodeScore model (implemented within the UniCE framework) predicts two key quantities:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"Executability (E)"})," \u2013 Whether the generated code can run successfully."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"PassRatio (P)"})," \u2013 The proportion of test cases passed."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"The training loss is defined as:"}),"\n",(0,s.jsx)(i.span,{className:"katex",children:(0,s.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,s.jsxs)(i.semantics,{children:[(0,s.jsxs)(i.mrow,{children:[(0,s.jsx)(i.mi,{children:"L"}),(0,s.jsx)(i.mo,{children:"="}),(0,s.jsxs)(i.msub,{children:[(0,s.jsx)(i.mi,{children:"L"}),(0,s.jsx)(i.mi,{children:"C"})]}),(0,s.jsx)(i.mo,{children:"+"}),(0,s.jsxs)(i.msub,{children:[(0,s.jsx)(i.mi,{children:"L"}),(0,s.jsx)(i.mi,{children:"E"})]})]}),(0,s.jsx)(i.annotation,{encoding:"application/x-tex",children:"L = L_C + L_E"})]})})}),"\n",(0,s.jsx)(i.p,{children:"Where:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.span,{className:"katex",children:(0,s.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(i.semantics,{children:[(0,s.jsxs)(i.mrow,{children:[(0,s.jsxs)(i.msub,{children:[(0,s.jsx)(i.mi,{children:"L"}),(0,s.jsx)(i.mi,{children:"C"})]}),(0,s.jsx)(i.mo,{children:"="}),(0,s.jsx)(i.mo,{stretchy:"false",children:"("}),(0,s.jsx)(i.mi,{children:"C"}),(0,s.jsx)(i.mi,{children:"o"}),(0,s.jsx)(i.mi,{children:"d"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"S"}),(0,s.jsx)(i.mi,{children:"c"}),(0,s.jsx)(i.mi,{children:"o"}),(0,s.jsx)(i.mi,{children:"r"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mo,{children:"\u2212"}),(0,s.jsx)(i.mi,{children:"P"}),(0,s.jsx)(i.mi,{children:"a"}),(0,s.jsx)(i.mi,{children:"s"}),(0,s.jsx)(i.mi,{children:"s"}),(0,s.jsx)(i.mi,{children:"R"}),(0,s.jsx)(i.mi,{children:"a"}),(0,s.jsx)(i.mi,{children:"t"}),(0,s.jsx)(i.mi,{children:"i"}),(0,s.jsx)(i.mi,{children:"o"}),(0,s.jsxs)(i.msup,{children:[(0,s.jsx)(i.mo,{stretchy:"false",children:")"}),(0,s.jsx)(i.mn,{children:"2"})]})]}),(0,s.jsx)(i.annotation,{encoding:"application/x-tex",children:"L_C = (CodeScore - PassRatio)^2"})]})})})," penalizes deviation from observed test outcomes."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.span,{className:"katex",children:(0,s.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(i.semantics,{children:[(0,s.jsxs)(i.mrow,{children:[(0,s.jsxs)(i.msub,{children:[(0,s.jsx)(i.mi,{children:"L"}),(0,s.jsx)(i.mi,{children:"E"})]}),(0,s.jsx)(i.mo,{children:"="}),(0,s.jsx)(i.mo,{children:"\u2212"}),(0,s.jsx)(i.mi,{children:"log"}),(0,s.jsx)(i.mo,{children:"\u2061"}),(0,s.jsx)(i.mi,{children:"p"}),(0,s.jsx)(i.mo,{stretchy:"false",children:"("}),(0,s.jsx)(i.mi,{children:"E"}),(0,s.jsx)(i.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(i.annotation,{encoding:"application/x-tex",children:"L_E = -\\log p(E)"})]})})})," is a binary cross-entropy loss predicting code executability."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"The model outputs a scalar CodeScore value:"}),"\n",(0,s.jsx)(i.span,{className:"katex",children:(0,s.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,s.jsxs)(i.semantics,{children:[(0,s.jsxs)(i.mrow,{children:[(0,s.jsx)(i.mi,{children:"C"}),(0,s.jsx)(i.mi,{children:"o"}),(0,s.jsx)(i.mi,{children:"d"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"S"}),(0,s.jsx)(i.mi,{children:"c"}),(0,s.jsx)(i.mi,{children:"o"}),(0,s.jsx)(i.mi,{children:"r"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mo,{children:"="}),(0,s.jsx)(i.mi,{children:"f"}),(0,s.jsx)(i.mo,{stretchy:"false",children:"("}),(0,s.jsx)(i.mi,{children:"g"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"n"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"r"}),(0,s.jsx)(i.mi,{children:"a"}),(0,s.jsx)(i.mi,{children:"t"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"d"}),(0,s.jsx)(i.mi,{mathvariant:"normal",children:"_"}),(0,s.jsx)(i.mi,{children:"c"}),(0,s.jsx)(i.mi,{children:"o"}),(0,s.jsx)(i.mi,{children:"d"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mo,{separator:"true",children:","}),(0,s.jsx)(i.mi,{children:"r"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"f"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"r"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"n"}),(0,s.jsx)(i.mi,{children:"c"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{mathvariant:"normal",children:"_"}),(0,s.jsx)(i.mi,{children:"c"}),(0,s.jsx)(i.mi,{children:"o"}),(0,s.jsx)(i.mi,{children:"d"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mo,{separator:"true",children:","}),(0,s.jsx)(i.mi,{children:"t"}),(0,s.jsx)(i.mi,{children:"a"}),(0,s.jsx)(i.mi,{children:"s"}),(0,s.jsx)(i.mi,{children:"k"}),(0,s.jsx)(i.mi,{mathvariant:"normal",children:"_"}),(0,s.jsx)(i.mi,{children:"d"}),(0,s.jsx)(i.mi,{children:"e"}),(0,s.jsx)(i.mi,{children:"s"}),(0,s.jsx)(i.mi,{children:"c"}),(0,s.jsx)(i.mi,{children:"r"}),(0,s.jsx)(i.mi,{children:"i"}),(0,s.jsx)(i.mi,{children:"p"}),(0,s.jsx)(i.mi,{children:"t"}),(0,s.jsx)(i.mi,{children:"i"}),(0,s.jsx)(i.mi,{children:"o"}),(0,s.jsx)(i.mi,{children:"n"}),(0,s.jsx)(i.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(i.annotation,{encoding:"application/x-tex",children:"CodeScore = f(generated\\_code, reference\\_code, task\\_description)"})]})})}),"\n",(0,s.jsx)(i.p,{children:"which approximates the true execution-based correctness without actually executing the code."}),"\n",(0,s.jsx)(i.h2,{id:"variants",children:"Variants"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"CodeScore:"})," Standard model-based evaluation score predicting execution correctness across benchmarks like APPS-Eval and MBPP-Eval."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"CodeScore-R:"})," A robustness-oriented extension that evaluates consistency and resilience under perturbations (e.g., renamed variables, reordered code). It focuses on the stability of the model\u2019s evaluation when faced with minor syntactic variations in the input."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"application-in-software-engineering",children:"Application in Software Engineering"}),"\n",(0,s.jsx)(i.p,{children:"CodeScore and its variants are primarily used to assess LLM-generated code across multiple software engineering tasks such as code completion, repair, and migration. They are valuable when running large-scale test execution is impractical due to cost or sandboxing limitations."}),"\n",(0,s.jsx)(i.p,{children:"Applications include:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"LLM-based Evaluation (CodeScore):"})," Estimating correctness of code generated by language models without executing test cases."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.em,{children:"Robustness / Functional Correctness (CodeScore-R):"})," Assessing reliability of model-generated code under code perturbations, ensuring that evaluations remain consistent even when surface syntax changes.\r\nIn benchmarks like HumanEval, HumanEval-X, AVATAR, and UniCE\u2019s evaluation suite, CodeScore-R has demonstrated stronger alignment with functional correctness than text-based metrics and higher robustness to input noise."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"interpretation",children:"Interpretation"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"High CodeScore or CodeScore-R values (close to 1) indicate code that is executable, semantically correct, and consistent across small perturbations."}),"\n",(0,s.jsx)(i.li,{children:"Moderate values may correspond to partially correct or non-executable but syntactically plausible code."}),"\n",(0,s.jsx)(i.li,{children:"Low scores reflect code that fails execution or deviates significantly from the intended task behavior.\r\nOverall, CodeScore offers an efficient and generalizable approach to evaluating code generation quality without relying solely on textual or exact-match metrics."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Dong, Y., Ding, J., Jiang, X., Li, G., Li, Z., & Jin, Z. (2023). CodeScore: Evaluating Code Generation by Learning Code Execution.",(0,s.jsx)(i.br,{}),"\n",(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2301.09043",children:"https://arxiv.org/abs/2301.09043"})]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"additional-references-in-dataset",children:"Additional References in Dataset"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"26,\xa037"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,c.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>a});var r=n(6540);const s={},c=r.createContext(s);function t(e){const i=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(c.Provider,{value:i},e.children)}}}]);