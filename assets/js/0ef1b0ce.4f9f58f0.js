"use strict";(self.webpackChunkll_ms_metrics_catalog=self.webpackChunkll_ms_metrics_catalog||[]).push([[1067],{6156:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"metrics/functional-test/solution-metrics","title":"Solution-Based Metrics","description":"Introduction","source":"@site/docs/metrics/functional-test/solution-metrics.md","sourceDirName":"metrics/functional-test","slug":"/metrics/functional-test/solution-metrics","permalink":"/LLMs-metrics-catalog/metrics/functional-test/solution-metrics","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"solution-metrics","title":"Solution-Based Metrics","sidebar_label":"Solution-Based Metrics"},"sidebar":"docsSidebar","previous":{"title":"Mutant Killings","permalink":"/LLMs-metrics-catalog/metrics/functional-test/mutant-killings"},"next":{"title":"Reasoning Depth","permalink":"/LLMs-metrics-catalog/metrics/functional-test/reasoning-depth"}}');var s=n(4848),o=n(8453);const r={id:"solution-metrics",title:"Solution-Based Metrics",sidebar_label:"Solution-Based Metrics"},l=void 0,a={},c=[{value:"Introduction",id:"introduction",level:2},{value:"1. Solution Elegance Score (SES)",id:"1-solution-elegance-score-ses",level:2},{value:"Definition",id:"definition",level:3},{value:"Purpose",id:"purpose",level:3},{value:"Applications",id:"applications",level:3},{value:"2. Solution Size / Average Lines of Code (ALOC)",id:"2-solution-size--average-lines-of-code-aloc",level:2},{value:"Definition",id:"definition-1",level:3},{value:"Purpose",id:"purpose-1",level:3},{value:"Applications",id:"applications-1",level:3},{value:"3. Comparative Summary",id:"3-comparative-summary",level:2},{value:"References",id:"references",level:2},{value:"Additional References",id:"additional-references",level:3}];function d(e){const i={a:"a",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(i.p,{children:["While many metrics focus on functional correctness (e.g., does the code pass unit tests?), ",(0,s.jsx)(i.strong,{children:"Solution-Based Metrics"})," evaluate the intrinsic qualities of the generated output itself. These metrics are used to analyze properties like the solution's length, its structural complexity, or its adherence to design principles."]}),"\n",(0,s.jsx)(i.p,{children:"This category is diverse, ranging from simple heuristics like code length to complex, model-based scores for assessing aesthetic quality. They are essential for a holistic evaluation, capturing aspects of maintainability and complexity that functional tests alone might miss."}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"1-solution-elegance-score-ses",children:"1. Solution Elegance Score (SES)"}),"\n",(0,s.jsx)(i.h3,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Solution Elegance Score (SES)"})," is a metric introduced in the LoCoBench benchmark that measures the aesthetic and design quality of generated code. It is based on established code aesthetics and design quality metrics, evaluating aspects like ",(0,s.jsx)(i.strong,{children:"code clarity"}),", ",(0,s.jsx)(i.strong,{children:"theoretical soundness"}),", and ",(0,s.jsx)(i.strong,{children:"adherence to clean code principles"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"purpose",children:"Purpose"}),"\n",(0,s.jsxs)(i.p,{children:["SES is used to evaluate sophisticated software engineering capabilities. It forms one of the 8 metrics in the ",(0,s.jsx)(i.strong,{children:"Software Engineering Excellence"})," dimension of the LoCoBench framework, which is weighted at 40% of the total LoCoBench Score (LCBS)."]}),"\n",(0,s.jsx)(i.h3,{id:"applications",children:"Applications"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Software Engineering (SE)"}),"\n",(0,s.jsx)(i.li,{children:"Evaluation of long-context code generation"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"2-solution-size--average-lines-of-code-aloc",children:"2. Solution Size / Average Lines of Code (ALOC)"}),"\n",(0,s.jsx)(i.h3,{id:"definition-1",children:"Definition"}),"\n",(0,s.jsx)(i.p,{children:"This is a heuristic metric that measures the length or verbosity of a generated code solution. It can be calculated in several ways:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Average Lines of Code (ALOC):"})," The total number of lines in the generated solution file."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Solution Size (Length):"}),' The total number of characters, sometimes excluding whitespace (e.g., "Length(No whitespace)").']}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"purpose-1",children:"Purpose"}),"\n",(0,s.jsx)(i.p,{children:"This metric is primarily used for analysis to examine the effect of different models or operators on the complexity and verbosity of the generated solutions. For example, the LLM_GP study used it to compare the growth of solution size over generations against a traditional GP baseline. It can also be used as a descriptive statistic for a benchmark's problem set (e.g., the DS-1000 benchmark notes the average lines of code in its solutions)."}),"\n",(0,s.jsx)(i.h3,{id:"applications-1",children:"Applications"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Code Evolution (e.g., LLM_GP)"}),"\n",(0,s.jsx)(i.li,{children:"Code Generation (e.g., DS-1000)"}),"\n",(0,s.jsx)(i.li,{children:"Structural Complexity Analysis"}),"\n"]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"3-comparative-summary",children:"3. Comparative Summary"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Metric"}),(0,s.jsx)(i.th,{children:"Based on"}),(0,s.jsx)(i.th,{children:"Primary Goal"}),(0,s.jsx)(i.th,{children:"Measurement"}),(0,s.jsx)(i.th,{children:"Domain"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Solution Elegance Score"})}),(0,s.jsx)(i.td,{children:"Code Aesthetics"}),(0,s.jsx)(i.td,{children:"Measure design quality & clarity"}),(0,s.jsx)(i.td,{children:"Qualitative score (clarity, soundness)"}),(0,s.jsx)(i.td,{children:"SE"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Solution Size / ALOC"})}),(0,s.jsx)(i.td,{children:"Heuristics"}),(0,s.jsx)(i.td,{children:"Measure solution verbosity/length"}),(0,s.jsx)(i.td,{children:"Count (lines, characters)"}),(0,s.jsx)(i.td,{children:"SE / Code Gen"})]})]})]}),"\n",(0,s.jsx)(i.hr,{}),"\n",(0,s.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Anand, A., Chopra, S., & Arora, M. (2025). ",(0,s.jsx)(i.em,{children:"Analysis of LLM Code Synthesis in Software Productivity"}),". In M. Saraswat & R. Kumari (eds.), Applied Intelligence and Computing. ",(0,s.jsx)(i.a,{href:"https://doi.org/10.56155/978-81-955020-9-7-24",children:"https://doi.org/10.56155/978-81-955020-9-7-24"})]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Gallegos, I. O., Rossi, R. A., Barrow, J., Tanjim, M. M., Kim, S., Dernoncourt, F., Yu, T., Zhang, R., & Ahmed, N. K. (2024). ",(0,s.jsx)(i.em,{children:"Bias and Fairness in Large Language Models: A Survey"}),". Computational Linguistics, 50(3). ",(0,s.jsx)(i.a,{href:"https://doi.org/10.1162/coli_a_00524",children:"https://doi.org/10.1162/coli_a_00524"})]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Hemberg, E., Moskal, S., & O'Reilly, U.-M. (2024). ",(0,s.jsx)(i.em,{children:"Evolving code with a large language model"}),". Genetic Programming and Evolvable Machines, 25(21).",(0,s.jsx)(i.a,{href:"https://doi.org/10.1007/s10710-024-09494-2",children:"https://doi.org/10.1007/s10710-024-09494-2"})]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Qiu, J., Liu, Z., Liu, Z., Murthy, R., Zhang, J., Chen, H., Wang, S., Zhu, M., Yang, L., Tan, J., Cen, Z., Qian, C., Heinecke, S., Yao, W., Savarese, S., Xiong, C., & Wang, H. (2025). ",(0,s.jsx)(i.em,{children:"LoCoBench: A Benchmark for Long-Context Large Language Models in Complex Software Engineering"}),". ",(0,s.jsx)(i.a,{href:"https://doi.org/10.48550/arXiv.2509.09614",children:"https://doi.org/10.48550/arXiv.2509.09614"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"additional-references",children:"Additional References"}),"\n",(0,s.jsx)(i.p,{children:"16, 18, 30, 54"})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>l});var t=n(6540);const s={},o=t.createContext(s);function r(e){const i=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);