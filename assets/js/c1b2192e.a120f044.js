"use strict";(self.webpackChunkll_ms_metrics_catalog=self.webpackChunkll_ms_metrics_catalog||[]).push([[2630],{3349:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"metrics/accuracy-overlap/coverage","title":"Coverage","description":"Introduction","source":"@site/docs/metrics/accuracy-overlap/coverage.md","sourceDirName":"metrics/accuracy-overlap","slug":"/metrics/accuracy-overlap/coverage","permalink":"/LLMs-metrics-catalog/metrics/accuracy-overlap/coverage","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"coverage","title":"Coverage","sidebar_label":"Coverage"},"sidebar":"docsSidebar","previous":{"title":"BERTScore","permalink":"/LLMs-metrics-catalog/metrics/accuracy-overlap/bertscore"},"next":{"title":"chrF","permalink":"/LLMs-metrics-catalog/metrics/accuracy-overlap/chrf"}}');var i=t(4848),s=t(8453);const a={id:"coverage",title:"Coverage",sidebar_label:"Coverage"},o=void 0,c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Formula",id:"formula",level:2},{value:"Variants",id:"variants",level:2},{value:"Applications in Software Engineering",id:"applications-in-software-engineering",level:2},{value:"Interpretation",id:"interpretation",level:2},{value:"References",id:"references",level:2},{value:"Additional References in Dataset",id:"additional-references-in-dataset",level:3}];function d(e){const n={a:"a",annotation:"annotation",br:"br",em:"em",h2:"h2",h3:"h3",li:"li",math:"math",mfrac:"mfrac",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",mtext:"mtext",ol:"ol",p:"p",semantics:"semantics",span:"span",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["Coverage is a metric used to evaluate how thoroughly a system, model, or set of test cases explores a given space\u2014most commonly code, input conditions, or tasks. In software engineering, code coverage quantifies the proportion of code elements (statements, branches, or functions) executed by test cases. High coverage indicates better validation and testing completeness, while low coverage reveals untested or unreachable code.\r\nRecent work (Tufano et al., 2023) extends this concept to predict coverage without executing code, proposing machine learning approaches that estimate coverage based on static or semantic representations.",(0,i.jsx)(n.br,{}),"\n","This evolution makes coverage relevant not only for software testing, but also for LLM-based code generation and evaluation of AI systems that produce executable artifacts."]}),"\n",(0,i.jsx)(n.h2,{id:"formula",children:"Formula"}),"\n",(0,i.jsx)(n.p,{children:"Coverage is typically computed as a ratio:"}),"\n",(0,i.jsx)(n.span,{className:"katex",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"C"}),(0,i.jsx)(n.mi,{children:"o"}),(0,i.jsx)(n.mi,{children:"v"}),(0,i.jsx)(n.mi,{children:"e"}),(0,i.jsx)(n.mi,{children:"r"}),(0,i.jsx)(n.mi,{children:"a"}),(0,i.jsx)(n.mi,{children:"g"}),(0,i.jsx)(n.mi,{children:"e"}),(0,i.jsx)(n.mo,{children:"="}),(0,i.jsxs)(n.mfrac,{children:[(0,i.jsx)(n.mtext,{children:"Number\xa0of\xa0elements\xa0covered"}),(0,i.jsx)(n.mtext,{children:"Total\xa0number\xa0of\xa0elements"})]}),(0,i.jsx)(n.mo,{children:"\xd7"}),(0,i.jsx)(n.mn,{children:"100"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"Coverage = \\frac{\\text{Number of elements covered}}{\\text{Total number of elements}} \\times 100"})]})})}),"\n",(0,i.jsxs)(n.p,{children:["Where \u201celements\u201d can refer to lines, statements, branches, methods, or any unit of analysis depending on the coverage type.",(0,i.jsx)(n.br,{}),"\n","Coverage values range from 0 % (no coverage) to 100 % (full coverage)."]}),"\n",(0,i.jsx)(n.h2,{id:"variants",children:"Variants"}),"\n",(0,i.jsx)(n.p,{children:"Coverage has several important variants depending on what is measured:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Code Coverage:"})," Fraction of source code executed during testing or generation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Branch Coverage:"})," Proportion of decision branches (e.g., if conditions) executed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Statement Coverage:"})," Portion of executable statements covered by tests."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Line Coverage:"})," Number of individual lines executed at least once."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Functional Coverage:"})," Extent to which functional requirements or test scenarios are exercised."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Coverage@ n:"})," Percentage of top-n generated solutions or test cases that achieve successful coverage."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Information Coverage Utilization:"})," Measures how efficiently contextual or memory resources (e.g., long-context models) are used to cover input information."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Coverage Diversity / Uniquely Covered Lines (%):"})," Indicates how distinct or non-redundant the covered regions are, highlighting variety across test suites."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Object Coverage (Generative Tasks):"})," Applied to multimodal or generative LLMs to quantify how completely generated objects or elements match reference sets."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"applications-in-software-engineering",children:"Applications in Software Engineering"}),"\n",(0,i.jsx)(n.p,{children:"Coverage is widely used across SE evaluation benchmarks to measure how effectively systems exercise or validate code and functionality.The metric appears in multiple research contexts, such as:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Test Quality and Effectiveness"})," \u2014 DevEval and TESTPILOT frameworks use coverage and branch coverage to estimate test adequacy and generation quality."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"LLM-based Code Generation"})," \u2014 Datasets like HumanEval+ and CoderUJB use coverage, coverage@n, and code coverage to measure the structural correctness of generated solutions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Security and Fuzzing Evaluation"})," \u2014 FuzzBench employs line coverage as an indicator of fuzzing performance and seed diversity."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Autonomous Agent Evaluation"})," \u2014 Benchmarks such as AgentBench apply coverage as a measure of task completion success in multi-step reasoning environments."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Generative and Multimodal Systems"})," \u2014 AMBER assesses object coverage for hallucination detection and generative completeness."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Long-Context Utilization"})," \u2014 LoCoBench introduces information coverage utilization, quantifying how effectively long context windows are used to access relevant content."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These examples show that coverage has evolved from a testing metric into a cross-domain evaluation criterion applicable to both traditional SE pipelines and modern LLM-driven generation tasks."}),"\n",(0,i.jsx)(n.h2,{id:"interpretation",children:"Interpretation"}),"\n",(0,i.jsx)(n.p,{children:"Coverage serves as a proxy for thoroughness and reliability:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"High coverage implies that the system, code generator, or test suite has explored a large portion of the search or execution space."}),"\n",(0,i.jsx)(n.li,{children:"However, high coverage does not necessarily guarantee correctness, as uncovered paths may still contain critical bugs or unverified functionality."}),"\n",(0,i.jsx)(n.li,{children:"In LLM-based SE evaluation, coverage helps estimate functional completeness, how much of the expected or reference behavior is actually represented in the generated output."}),"\n",(0,i.jsx)(n.li,{children:"Coverage diversity and information utilization provide additional insight into robustness and generalization by revealing whether models rely on narrow or broad exploration.\r\nIn short, coverage reflects how well a system \u201csees\u201d its problem space, bridging quality assurance in traditional testing with behavioral analysis of generative AI models."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Tufano, M., Chandel, S., Agarwal, A., Sundaresan, N., & Clement, C. (2023)."})," Predicting Code Coverage without Execution.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2307.13383",children:"https://arxiv.org/abs/2307.13383"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"additional-references-in-dataset",children:"Additional References in Dataset"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"8, 10, 13, 20, 49, 54,\xa059, 64, 67"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);