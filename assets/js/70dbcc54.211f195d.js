"use strict";(self.webpackChunkll_ms_metrics_catalog=self.webpackChunkll_ms_metrics_catalog||[]).push([[8957],{4345:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"metrics/ranking/relative-improvement","title":"Relative Improvement (RImp)","description":"Definition","source":"@site/docs/metrics/ranking/relative-improvement.md","sourceDirName":"metrics/ranking","slug":"/metrics/ranking/relative-improvement","permalink":"/LLMs-metrics-catalog/metrics/ranking/relative-improvement","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"relative-improvement","title":"Relative Improvement (RImp)","sidebar_label":"RImp"},"sidebar":"docsSidebar","previous":{"title":"MC Brier Score","permalink":"/LLMs-metrics-catalog/metrics/ranking/multiple-choice-brier-score"},"next":{"title":"Reward Score","permalink":"/LLMs-metrics-catalog/metrics/ranking/reward-score"}}');var a=t(4848),s=t(8453);const r={id:"relative-improvement",title:"Relative Improvement (RImp)",sidebar_label:"RImp"},o=void 0,l={},c=[{value:"Definition",id:"definition",level:2},{value:"Formula (General Idea)",id:"formula-general-idea",level:2},{value:"Purpose",id:"purpose",level:2},{value:"Domains",id:"domains",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Key References",id:"key-references",level:2}];function d(e){const n={a:"a",annotation:"annotation",h2:"h2",hr:"hr",li:"li",math:"math",mfrac:"mfrac",mo:"mo",mrow:"mrow",msub:"msub",mtext:"mtext",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Relative Improvement (RImp)"})," is an evaluation metric used in Fault Localization (FL) to assess the effectiveness of a specific FL technique."]}),"\n",(0,a.jsxs)(n.p,{children:["It is calculated by comparing the total number of statements a developer would need to examine to find all faults ",(0,a.jsx)(n.strong,{children:"using"})," a specific FL approach versus the total number of statements they would need to examine ",(0,a.jsx)(n.strong,{children:"without"})," using that approach."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"formula-general-idea",children:"Formula (General Idea)"}),"\n",(0,a.jsx)(n.p,{children:"The metric is a prose-based comparison rather than a strict formula in the provided text. It is defined as a comparison of the developer effort (measured in statements examined) with and without the fault localization technique."}),"\n",(0,a.jsx)(n.p,{children:"A common calculation for relative improvement (though not explicitly written as a formula in the source) would be:"}),"\n",(0,a.jsx)(n.span,{className:"katex",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mtext,{children:"RImp"}),(0,a.jsx)(n.mo,{children:"="}),(0,a.jsxs)(n.mfrac,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mtext,{children:"Statements"}),(0,a.jsx)(n.mtext,{children:"baseline"})]}),(0,a.jsx)(n.mo,{children:"\u2212"}),(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mtext,{children:"Statements"}),(0,a.jsx)(n.mtext,{children:"FL_technique"})]})]}),(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mtext,{children:"Statements"}),(0,a.jsx)(n.mtext,{children:"baseline"})]})]})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\text{RImp} = \\frac{\\text{Statements}_{\\text{baseline}} - \\text{Statements}_{\\text{FL\\_technique}}}{\\text{Statements}_{\\text{baseline}}}"})]})})}),"\n",(0,a.jsx)(n.p,{children:"Where:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.span,{className:"katex",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mtext,{children:"Statements"}),(0,a.jsx)(n.mtext,{children:"baseline"})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\text{Statements}_{\\text{baseline}}"})]})})})," = Total statements examined to find all faults without the FL approach."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.span,{className:"katex",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msub,{children:[(0,a.jsx)(n.mtext,{children:"Statements"}),(0,a.jsx)(n.mtext,{children:"FL_technique"})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\text{Statements}_{\\text{FL\\_technique}}"})]})})})," = Total statements examined to find all faults using the FL approach."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,a.jsx)(n.p,{children:"The purpose of RImp is to quantify the practical benefit or efficiency gain provided by a fault localization technique. It directly measures the reduction in developer effort (in terms of code statements to review) required to locate all faults, providing a clear indicator of a technique's value."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"domains",children:"Domains"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Software Engineering"}),"\n",(0,a.jsx)(n.li,{children:"Fault Localization (FL)"}),"\n",(0,a.jsx)(n.li,{children:"Deep-Learning-based Fault Localization (DLFL)"}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"advantages",children:"Advantages"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Measures Practical Effort:"})," Directly quantifies the reduction in developer effort, making it a practical metric for assessing a tool's usefulness."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Clear Interpretation:"})," A higher RImp score clearly indicates a more effective localization technique."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"key-references",children:"Key References"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Chen, X., Hu, X., Huang, Y., Ma, L., Wang, H., Wang, J., Xia, X., Yang, Y., Yu, Z., Zhang, Y., & Xie, T. (2025). Deep learning-based software engineering: Progress, challenges, and opportunities. Science China Information Sciences, 68, 111102. ",(0,a.jsx)(n.a,{href:"https://doi.org/10.1007/s11432-023-4127-5",children:"https://doi.org/10.1007/s11432-023-4127-5"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Zhang, Z., Lei, Y., Tan, Q., Mao, X., & Zeng, P. (2017). Deep learning-based fault localization with contextual information. IEICE Transactions on Information and Systems, E100.D(12), 3027\u20133030. ",(0,a.jsx)(n.a,{href:"https://doi.org/10.1587/transinf.2017EDL8143",children:"https://doi.org/10.1587/transinf.2017EDL8143"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Zhang, Z., Lei, Y., Mao, X., & Zeng, P. (2019). CNN-FL: An effective approach for localizing faults using convolutional neural networks. 2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER), 445\u2013455. IEEE. ",(0,a.jsx)(n.a,{href:"https://doi.org/10.1109/SANER.2019.8668002",children:"https://doi.org/10.1109/SANER.2019.8668002"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Zhang, Z., Lei, Y., Mao, X., & Zeng, P. (2023). Context-aware neural fault localization. IEEE Transactions on Software Engineering, 49(7), 3862\u20133883. ",(0,a.jsx)(n.a,{href:"https://doi.org/10.1109/TSE.2023.3279125",children:"https://doi.org/10.1109/TSE.2023.3279125"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Yu, J., Lei, Y., Xie, H., & Mao, X. (2022). Context-based cluster fault localization. Proceedings of the 30th IEEE/ACM International Conference on Program Comprehension, 184\u2013195. Association for Computing Machinery. ",(0,a.jsx)(n.a,{href:"https://doi.org/10.1145/3524610.3527891",children:"https://doi.org/10.1145/3524610.3527891"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Lei, Y., Wen, T., Xie, H., & Mao, X. (2023). Mitigating the effect of class imbalance in fault localization using context-aware generative adversarial network. arXiv. ",(0,a.jsx)(n.a,{href:"https://doi.org/10.48550/arXiv.2303.06644",children:"https://doi.org/10.48550/arXiv.2303.06644"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Zhang, Z., Lei, Y., Su, T., Tan, Q., & Mao, X. (2024). Influential global and local contexts guided trace representation for fault localization. ACM Transactions on Software Engineering and Methodology, 33(2), 1\u201333. ",(0,a.jsx)(n.a,{href:"https://doi.org/10.1145/3576043",children:"https://doi.org/10.1145/3576043"})]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);