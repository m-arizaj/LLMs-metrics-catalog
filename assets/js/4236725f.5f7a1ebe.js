"use strict";(self.webpackChunkll_ms_metrics_catalog=self.webpackChunkll_ms_metrics_catalog||[]).push([[6512],{1504:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"metrics/statistical/smape","title":"Smape","description":"Introduction","source":"@site/docs/metrics/statistical/smape.md","sourceDirName":"metrics/statistical","slug":"/metrics/statistical/smape","permalink":"/LLMs-metrics-catalog/metrics/statistical/smape","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"smape","title":"Smape","sidebar_label":"Smape"},"sidebar":"docsSidebar","previous":{"title":"Cohen\'s Score","permalink":"/LLMs-metrics-catalog/metrics/statistical/cohen"},"next":{"title":"Rate Metrics","permalink":"/LLMs-metrics-catalog/metrics/statistical/rate"}}');var r=n(4848),a=n(8453);const t={id:"smape",title:"Smape",sidebar_label:"Smape"},l=void 0,c={},o=[{value:"Introduction",id:"introduction",level:2},{value:"Formula",id:"formula",level:2},{value:"Variants",id:"variants",level:2},{value:"Application in Software Engineering",id:"application-in-software-engineering",level:2},{value:"Interpretation",id:"interpretation",level:2},{value:"References",id:"references",level:2},{value:"Additional Reference in Database",id:"additional-reference-in-database",level:3}];function d(e){const i={a:"a",annotation:"annotation",br:"br",em:"em",h2:"h2",h3:"h3",li:"li",math:"math",mfrac:"mfrac",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",munderover:"munderover",ol:"ol",p:"p",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(i.p,{children:"Symmetric Mean Absolute Percentage Error (SMAPE) is a normalized regression metric used to measure the relative prediction accuracy between model outputs and true values. Unlike Mean Absolute Percentage Error (MAPE), SMAPE introduces a symmetric denominator to reduce bias when actual values are close to zero.  It is especially useful in evaluating model performance for forecasting, regression, and software engineering tasks where balanced error scaling is important."}),"\n",(0,r.jsx)(i.h2,{id:"formula",children:"Formula"}),"\n",(0,r.jsx)(i.p,{children:"The standard definition of SMAPE is given by:"}),"\n",(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsxs)(i.mrow,{children:[(0,r.jsx)(i.mi,{children:"S"}),(0,r.jsx)(i.mi,{children:"M"}),(0,r.jsx)(i.mi,{children:"A"}),(0,r.jsx)(i.mi,{children:"P"}),(0,r.jsx)(i.mi,{children:"E"}),(0,r.jsx)(i.mo,{children:"="}),(0,r.jsxs)(i.mfrac,{children:[(0,r.jsx)(i.mn,{children:"100"}),(0,r.jsx)(i.mi,{children:"n"})]}),(0,r.jsxs)(i.munderover,{children:[(0,r.jsx)(i.mo,{children:"\u2211"}),(0,r.jsxs)(i.mrow,{children:[(0,r.jsx)(i.mi,{children:"i"}),(0,r.jsx)(i.mo,{children:"="}),(0,r.jsx)(i.mn,{children:"1"})]}),(0,r.jsx)(i.mi,{children:"n"})]}),(0,r.jsxs)(i.mfrac,{children:[(0,r.jsxs)(i.mrow,{children:[(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"F"}),(0,r.jsx)(i.mi,{children:"i"})]}),(0,r.jsx)(i.mo,{children:"\u2212"}),(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"A"}),(0,r.jsx)(i.mi,{children:"i"})]}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"})]}),(0,r.jsxs)(i.mrow,{children:[(0,r.jsx)(i.mo,{stretchy:"false",children:"("}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"A"}),(0,r.jsx)(i.mi,{children:"i"})]}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsx)(i.mo,{children:"+"}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"F"}),(0,r.jsx)(i.mi,{children:"i"})]}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsx)(i.mo,{stretchy:"false",children:")"}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"/"}),(0,r.jsx)(i.mn,{children:"2"})]})]})]}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"SMAPE = \\frac{100}{n} \\sum_{i=1}^{n} \\frac{|F_i - A_i|}{(|A_i| + |F_i|)/2}"})]})})}),"\n",(0,r.jsx)(i.p,{children:"where:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsx)(i.mrow,{children:(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"F"}),(0,r.jsx)(i.mi,{children:"i"})]})}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"F_i"})]})})})," = predicted value for instance ",(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsx)(i.mrow,{children:(0,r.jsx)(i.mi,{children:"i"})}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"i"})]})})}),","]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsx)(i.mrow,{children:(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"A"}),(0,r.jsx)(i.mi,{children:"i"})]})}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"A_i"})]})})})," = actual (true) value for instance ",(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsx)(i.mrow,{children:(0,r.jsx)(i.mi,{children:"i"})}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"i"})]})})}),","]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsx)(i.mrow,{children:(0,r.jsx)(i.mi,{children:"n"})}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"n"})]})})})," = total number of instances."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"This formulation bounds the metric between 0% and 200%, but some variants normalize it by 2, restricting it to the range [0%, 100%]."}),"\n",(0,r.jsx)(i.h2,{id:"variants",children:"Variants"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.em,{children:"Normalized SMAPE:"})," Divides by ",(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsxs)(i.mrow,{children:[(0,r.jsx)(i.mo,{stretchy:"false",children:"("}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"A"}),(0,r.jsx)(i.mi,{children:"i"})]}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsx)(i.mo,{children:"+"}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"F"}),(0,r.jsx)(i.mi,{children:"i"})]}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsx)(i.mo,{stretchy:"false",children:")"})]}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"(|A_i| + |F_i|)"})]})})})," instead of ",(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsxs)(i.mrow,{children:[(0,r.jsx)(i.mo,{stretchy:"false",children:"("}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"A"}),(0,r.jsx)(i.mi,{children:"i"})]}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsx)(i.mo,{children:"+"}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"F"}),(0,r.jsx)(i.mi,{children:"i"})]}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,r.jsx)(i.mo,{stretchy:"false",children:")"}),(0,r.jsx)(i.mi,{mathvariant:"normal",children:"/"}),(0,r.jsx)(i.mn,{children:"2"})]}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"(|A_i| + |F_i|)/2"})]})})}),", resulting in a metric scaled up to 200%."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.em,{children:"Bounded SMAPE:"})," Applies an additional scaling factor of 0.5 to ensure values remain within 0\u2013100%."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.em,{children:"Weighted SMAPE:"})," Introduces instance weights to handle imbalanced datasets where large magnitudes could dominate the error measure."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"application-in-software-engineering",children:"Application in Software Engineering"}),"\n",(0,r.jsxs)(i.p,{children:["In software engineering and LLM evaluation, SMAPE is primarily used for regression evaluation in non-code prediction tasks, such as estimating software metrics, predicting defect ratios, or analyzing resource usage.",(0,r.jsx)(i.br,{}),"\n","By normalizing both prediction and target values, it allows fair comparison across heterogeneous data distributions and avoids inflation of percentage errors when values are small."]}),"\n",(0,r.jsx)(i.p,{children:"The benchmark SELU (2025) employs SMAPE as part of its regression evaluation framework to assess predictive model calibration and accuracy in non-code SE contexts."}),"\n",(0,r.jsx)(i.h2,{id:"interpretation",children:"Interpretation"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.em,{children:"Low SMAPE (close to 0%)"})," indicates high predictive accuracy."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.em,{children:"High SMAPE (close to 100%)"})," signifies large relative deviation between predictions and true values."]}),"\n",(0,r.jsx)(i.li,{children:"Unlike MAPE, SMAPE does not overly penalize overestimations or underestimations, maintaining symmetry in error scaling."}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["However, SMAPE can still become unstable when both ",(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsx)(i.mrow,{children:(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"A"}),(0,r.jsx)(i.mi,{children:"i"})]})}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"A_i"})]})})})," and ",(0,r.jsx)(i.span,{className:"katex",children:(0,r.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(i.semantics,{children:[(0,r.jsx)(i.mrow,{children:(0,r.jsxs)(i.msub,{children:[(0,r.jsx)(i.mi,{children:"F"}),(0,r.jsx)(i.mi,{children:"i"})]})}),(0,r.jsx)(i.annotation,{encoding:"application/x-tex",children:"F_i"})]})})})," are near zero, and alternative formulations (e.g., Mean Absolute Scaled Error, MASE) may be preferable in such cases."]}),"\n",(0,r.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.em,{children:"Makridakis, S., Spiliotis, E. (2017)."})," A new accuracy measure based on bounded relative error for time series forecasting. PLoS ONE, 12(3): e0174202.",(0,r.jsx)(i.br,{}),"\n",(0,r.jsx)(i.a,{href:"https://doi.org/10.1371/journal.pone.0174202",children:"https://doi.org/10.1371/journal.pone.0174202"})]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.em,{children:"Kreinovich, V., et al. (2014)."})," How to Estimate Forecasting Quality: A System-Motivated Derivation of Symmetric Mean Absolute Percentage Error (SMAPE).",(0,r.jsx)(i.br,{}),"\n","Technical Report, University of Texas at El Paso.",(0,r.jsx)(i.br,{}),"\n",(0,r.jsx)(i.a,{href:"https://scholarworks.utep.edu/cgi/viewcontent.cgi?article=1865&context=cs_techrep",children:"https://scholarworks.utep.edu/cgi/viewcontent.cgi?article=1865&context=cs_techrep"})]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"additional-reference-in-database",children:"Additional Reference in Database"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"55"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>l});var s=n(6540);const r={},a=s.createContext(r);function t(e){const i=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(a.Provider,{value:i},e.children)}}}]);