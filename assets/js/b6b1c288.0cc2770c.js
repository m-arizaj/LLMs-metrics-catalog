"use strict";(self.webpackChunkll_ms_metrics_catalog=self.webpackChunkll_ms_metrics_catalog||[]).push([[8443],{7665:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"metrics/functional-test/mutant-killings","title":"Mutant Killings (Mutation Score)","description":"Definition","source":"@site/docs/metrics/functional-test/mutant-killings.md","sourceDirName":"metrics/functional-test","slug":"/metrics/functional-test/mutant-killings","permalink":"/LLMs-metrics-catalog/metrics/functional-test/mutant-killings","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"mutant-killings","title":"Mutant Killings (Mutation Score)","sidebar_label":"Mutant Killings"},"sidebar":"docsSidebar","previous":{"title":"Test Metrics","permalink":"/LLMs-metrics-catalog/metrics/functional-test/test"},"next":{"title":"Solution-Based Metrics","permalink":"/LLMs-metrics-catalog/metrics/functional-test/solution-metrics"}}');var s=n(4848),a=n(8453);const r={id:"mutant-killings",title:"Mutant Killings (Mutation Score)",sidebar_label:"Mutant Killings"},l=void 0,o={},c=[{value:"Definition",id:"definition",level:2},{value:"Formula (General Idea)",id:"formula-general-idea",level:2},{value:"Purpose",id:"purpose",level:2},{value:"Domains",id:"domains",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Key References",id:"key-references",level:2}];function u(e){const t={a:"a",annotation:"annotation",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",math:"math",mfrac:"mfrac",mo:"mo",mrow:"mrow",mtext:"mtext",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Mutant Killings"}),", also known as ",(0,s.jsx)(t.strong,{children:"Mutation Score"}),", is a metric used to precisely evaluate the effectiveness of a test suite. It is derived from ",(0,s.jsx)(t.strong,{children:"Mutation Testing (or Mutation Analysis)"}),", a technique that involves:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:['Creating a large number of artificial buggy versions of a program (the "ground-truth solution"). Each version is called a ',(0,s.jsx)(t.strong,{children:"mutant"})," and contains one subtle, seeded bug (e.g., changing a ",(0,s.jsx)(t.code,{children:"<"})," to a ",(0,s.jsx)(t.code,{children:">"}),")."]}),"\n",(0,s.jsx)(t.li,{children:"Running the test suite against these mutants."}),"\n",(0,s.jsxs)(t.li,{children:["If a test case causes a mutant to fail (i.e., it detects the bug), that mutant is considered ",(0,s.jsx)(t.strong,{children:'"killed"'}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'The "Mutant Killings" metric is the resulting score that measures what percentage of mutants the test suite successfully detected.'}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"formula-general-idea",children:"Formula (General Idea)"}),"\n",(0,s.jsxs)(t.p,{children:["The metric is formally known as the ",(0,s.jsx)(t.strong,{children:"Mutation Score"}),", which is the ratio of killed mutants to the total number of non-equivalent mutants."]}),"\n",(0,s.jsx)(t.span,{className:"katex",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mtext,{children:"Mutation\xa0Score"}),(0,s.jsx)(t.mo,{children:"="}),(0,s.jsxs)(t.mfrac,{children:[(0,s.jsx)(t.mtext,{children:"Number\xa0of\xa0Killed\xa0Mutants"}),(0,s.jsx)(t.mtext,{children:"Total\xa0Number\xa0of\xa0Mutants"})]})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\text{Mutation Score} = \\frac{\\text{Number of Killed Mutants}}{\\text{Total Number of Mutants}}"})]})})}),"\n",(0,s.jsx)(t.p,{children:"A higher score indicates a more effective test suite, as it can detect a larger percentage of the seeded bugs."}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"purpose",children:"Purpose"}),"\n",(0,s.jsxs)(t.p,{children:["The primary purpose of measuring mutant killings is to ",(0,s.jsx)(t.strong,{children:"quantify test effectiveness more precisely than code coverage"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"A test suite might achieve high code coverage (executing most of the code) but still be ineffective at finding critical defects. Mutation testing provides a better assessment by checking if the tests can actually detect faults (the mutants)."}),"\n",(0,s.jsxs)(t.p,{children:['In the context of evaluating LLM-generated code, it is used as a "testing requirement" for ',(0,s.jsx)(t.strong,{children:"test-suite reduction"}),". The goal is to create a minimal set of tests (like in the HumanEval+-Mini benchmark) that preserves the full test suite's effectiveness, meaning the reduced suite can still kill the same set of mutants."]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"domains",children:"Domains"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Software Engineering"}),"\n",(0,s.jsx)(t.li,{children:"Test Effectiveness Evaluation"}),"\n",(0,s.jsx)(t.li,{children:"Mutation Analysis"}),"\n",(0,s.jsx)(t.li,{children:"Test-Suite Reduction"}),"\n",(0,s.jsx)(t.li,{children:"Code Generation (for evaluating test suites in benchmarks)"}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"advantages",children:"Advantages"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Precise Effectiveness Measure:"})," It is considered a more precise and rigorous way to evaluate test suite quality compared to code coverage."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Focuses on Defect Detection:"})," Instead of just measuring which lines are executed, it measures the test suite's actual ability to find faults."]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"limitations",children:"Limitations"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Theoretical Basis:"}),' It is a "theoretical" metric of test adequacy, based on artificial bugs (mutants). This may not perfectly align with "empirical" effectiveness, such as the ability to detect real, incorrect samples generated by LLMs.']}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Cost:"})," Generating and running tests against a large number of mutants can be computationally expensive (though this is a limitation of the technique, not the metric itself)."]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"key-references",children:"Key References"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Liu, J., Xia, C. S., Wang, Y., & Zhang, L. (2023). ",(0,s.jsx)(t.em,{children:"Is Your Code Generated by ChatGPT Really Correct? Rigorous Evaluation of Large Language Models for Code Generation."})," arXiv:2305.01210v3. ",(0,s.jsx)(t.a,{href:"https://doi.org/10.48550/arXiv.2305.01210",children:"https://doi.org/10.48550/arXiv.2305.01210"})]}),"\n",(0,s.jsx)(t.li,{children:"(Excel Data: Paper 20)"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var i=n(6540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);