"use strict";(self.webpackChunkll_ms_metrics_catalog=self.webpackChunkll_ms_metrics_catalog||[]).push([[667],{13:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"metrics/logical/difference-automata","title":"Difference Automata","description":"Introduction","source":"@site/docs/metrics/logical/difference-automata.md","sourceDirName":"metrics/logical","slug":"/metrics/logical/difference-automata","permalink":"/LLMs-metrics-catalog/metrics/logical/difference-automata","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"difference-automata","title":"Difference Automata","sidebar_label":"Difference Automata"},"sidebar":"docsSidebar","previous":{"title":"Cog Metric","permalink":"/LLMs-metrics-catalog/metrics/logical/cog-metric"},"next":{"title":"EXAM","permalink":"/LLMs-metrics-catalog/metrics/logical/exam"}}');var a=i(4848),r=i(8453);const o={id:"difference-automata",title:"Difference Automata",sidebar_label:"Difference Automata"},s=void 0,l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"1. Difference Automata",id:"1-difference-automata",level:2},{value:"Definition",id:"definition",level:3},{value:"Purpose",id:"purpose",level:3},{value:"Applications",id:"applications",level:3},{value:"Limitations",id:"limitations",level:3},{value:"2. Nonempty Difference Automaton Indicator",id:"2-nonempty-difference-automaton-indicator",level:2},{value:"Definition",id:"definition-1",level:3},{value:"Purpose",id:"purpose-1",level:3},{value:"Applications",id:"applications-1",level:3},{value:"3. Comparative Summary",id:"3-comparative-summary",level:2},{value:"References",id:"references",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Difference Automata"})," are a validation metric used in software engineering, particularly for verifying system migration and ensuring behavioral equivalence. Unlike metrics that produce a single score, a Difference Automaton is a complete, learnable behavioral model (specifically a Mealy or Moore machine)."]}),"\n",(0,a.jsxs)(t.p,{children:['This metric is generated by simultaneously testing two versions of a system (e.g., a source and a target) to "fully characterize the behavioral discrepancies between the two compared models"=. The paper by ',(0,a.jsx)(t.strong,{children:"Busch et al. (2025)"})," uses this technique to automatically validate the correctness of an LLM-based migration from JavaScript to TypeScript."]}),"\n",(0,a.jsxs)(t.p,{children:["A key application of this model is the ",(0,a.jsx)(t.strong,{children:"Nonempty Difference Automaton Indicator"}),", which serves as a direct and intuitive signal for detecting migration errors."]}),"\n",(0,a.jsx)(t.h2,{id:"1-difference-automata",children:"1. Difference Automata"}),"\n",(0,a.jsx)(t.h3,{id:"definition",children:"Definition"}),"\n",(0,a.jsx)(t.p,{children:'A Difference Automaton is a behavioral model (e.g., a Mealy or Moore machine) that is inferred by "simultaneously testing two systems for discrepancies"=. It is designed to "fully characterize the behavioral differences" between two systems, such as an original and a migrated application. The resulting automaton model "show[s] all traces that lead to the occurrence of divergent behavior".'}),"\n",(0,a.jsx)(t.h3,{id:"purpose",children:"Purpose"}),"\n",(0,a.jsxs)(t.p,{children:["The primary purpose of this metric is ",(0,a.jsx)(t.strong,{children:"Behavioral Equivalence Verification"}),'. It is "ideal for quality control because they clearly show behavioral differences before and after migration"=. The paper uses them to "detect and visualize behavioral differences that are the result of the LLM-supported migration process".']}),"\n",(0,a.jsx)(t.h3,{id:"applications",children:"Applications"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Validation of system migration, specifically the LLM-based migration of a Webstory application from JavaScript to TypeScript."}),"\n",(0,a.jsx)(t.li,{children:'Used to "systematically compar[e] the models generated before and after migration".'}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"limitations",children:"Limitations"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The validation method relies on the scalability of Active Automata Learning (AAL), which requires managing the size of the learning alphabets and the inferred models to remain feasible."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"2-nonempty-difference-automaton-indicator",children:"2. Nonempty Difference Automaton Indicator"}),"\n",(0,a.jsx)(t.h3,{id:"definition-1",children:"Definition"}),"\n",(0,a.jsxs)(t.p,{children:["This is a derived binary metric based on the ",(0,a.jsx)(t.code,{children:"Difference Automata"}),' model. It is a simple check to see if the inferred difference automaton is "nonempty" (i.e., contains any states or transitions indicating a difference).']}),"\n",(0,a.jsx)(t.h3,{id:"purpose-1",children:"Purpose"}),"\n",(0,a.jsxs)(t.p,{children:["This metric is used for ",(0,a.jsx)(t.strong,{children:"Migration Error Detection"}),'. The logic is direct: "Any nonempty difference automaton serves as an intuitive indicator of an erroneous migration". Conversely, "The migration is correct whenever there is no input with a nonempty difference automaton".']}),"\n",(0,a.jsx)(t.h3,{id:"applications-1",children:"Applications"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Serves as the primary signal for validating the correctness of the LLM-based JavaScript-to-TypeScript migration."}),"\n",(0,a.jsx)(t.li,{children:'Described as the "most convenient way to detect behavioral discrepancies introduced by migration".'}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"3-comparative-summary",children:"3. Comparative Summary"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"Metric"}),(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"Based on"}),(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"Extension Goal"}),(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"Output"}),(0,a.jsx)(t.th,{style:{textAlign:"left"},children:"Typical Domain"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"left"},children:(0,a.jsx)(t.strong,{children:"Difference Automata"})}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"Active Automata Learning"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"Behavioral Equivalence Verification"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"A behavioral model showing all divergent traces"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"Software Migration / Validation"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"left"},children:(0,a.jsx)(t.strong,{children:"Nonempty Difference Automaton Indicator"})}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"Difference Automata"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"Migration Error Detection"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"A binary signal indicating if an error was found"}),(0,a.jsx)(t.td,{style:{textAlign:"left"},children:"Software Migration / Validation"})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Busch, D., Bainczyk, A., Smyth, S. et al. LLM-based code generation and system migration in language-driven engineering. Int J Softw Tools Technol Transfer 27, 137\u2013147 (2025). ",(0,a.jsx)(t.a,{href:"https://doi-org.ezproxy.uniandes.edu.co/10.1007/s10009-025-00798-x",children:"https://doi-org.ezproxy.uniandes.edu.co/10.1007/s10009-025-00798-x"})]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>s});var n=i(6540);const a={},r=n.createContext(a);function o(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);